{% extends "layout.html" %}

{% block body %}
  <nav class="navbar navbar-expand-lg navbar-dark bg-danger sticky-top">
    <div class="container-fluid">
      <span class="navbar-brand">
        Heim
      </span>

      <div class="justify-content-md-center" id="location-switcher">
        <div class="d-flex">
          <div class="btn-group">
            {% for location in locations %}
              <a class="btn btn-outline-light btn-sm {% if location.id == current_location.id %}active{% endif %}" href="/{{ location.id }}/">
                {{ location.name }}
              </a>
            {% endfor %}
          </div>
        </div>
      </div>

      <ul class="navbar-nav">
        <li class="nav-item">
          <a href="/logout/" class="nav-link">Log out</a>
        </li>
      </ul>
    </div>
  </nav>

  <main class="container">
    <div class="row">
      {% if forecast_data %}
      <div class="col-12 mt-4">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">Forecast</h5>
            <canvas id="forecast-chart"></canvas>
          </div>
        </div>
      </div>
      {% endif %}
      {% for sensor in sensor_data %}
      <div class="col-12 col-md-6 mt-4">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">{{ sensor.name }}</h5>
            <canvas id="chart-{{ loop.index }}"></canvas>
          </div>
        </div>
      </div>
      {% else %}
      <div class="col-12 mt-4">
        <p class="text-muted">No sensor data available.</p>
      </div>
      {% endfor %}
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script>
    const forecastData = {{ forecast_data | tojson }};
    if (forecastData) {
      const ctx = document.getElementById('forecast-chart');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: forecastData.labels.map(l => new Date(l)),
          datasets: [{
            label: 'Temperature',
            data: forecastData.values,
            borderColor: '#0d6efd',
            tension: 0.1,
            fill: false,
            pointRadius: 0,
          }]
        },
        options: {
          responsive: true,
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'day',
              },
              ticks: {
                display: false,
              },
            },
            xLabels: {
              type: 'time',
              position: 'bottom',
              time: {
                unit: 'day',
                displayFormats: {
                  day: 'EEE'
                }
              },
              ticks: {
                maxRotation: 0,
              },
              grid: {
                display: false,
              },
              afterDataLimits: function(axis) {
                // Sync with main x-axis
                axis.min = axis.chart.scales.x.min;
                axis.max = axis.chart.scales.x.max;
              },
              afterBuildTicks: function(axis) {
                const halfDay = 12 * 60 * 60 * 1000;
                const oneDay = 24 * 60 * 60 * 1000;

                // Add tick for first day if missing
                const firstDayMidnight = Math.floor(axis.min / oneDay) * oneDay;
                if (!axis.ticks.some(t => t.value === firstDayMidnight)) {
                  axis.ticks.unshift({ value: firstDayMidnight });
                }

                axis.ticks = axis.ticks
                  .map(tick => ({
                    ...tick,
                    value: tick.value + halfDay
                  }))
                  .filter(tick => tick.value <= axis.max);
              }
            },
            y: { beginAtZero: false }
          }
        }
      });
    }

    const sensorData = {{ sensor_data | tojson }};
    sensorData.forEach((sensor, index) => {
      const ctx = document.getElementById(`chart-${index + 1}`);
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: sensor.labels.map(l => new Date(l)),
          datasets: [{
            label: 'Temperature',
            data: sensor.values,
            borderColor: '#dc3545',
            tension: 0.1,
            fill: false,
            pointRadius: 0,
          }]
        },
        options: {
          responsive: true,
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'day',
              },
              ticks: {
                display: false,
              },
            },
            xLabels: {
              type: 'time',
              position: 'bottom',
              time: {
                unit: 'day',
                displayFormats: {
                  day: 'EEE'
                }
              },
              ticks: {
                maxRotation: 0,
              },
              grid: {
                display: false,
              },
              afterDataLimits: function(axis) {
                axis.min = axis.chart.scales.x.min;
                axis.max = axis.chart.scales.x.max;
              },
              afterBuildTicks: function(axis) {
                const halfDay = 12 * 60 * 60 * 1000;
                const oneDay = 24 * 60 * 60 * 1000;

                // Add tick for first day if missing
                const firstDayMidnight = Math.floor(axis.min / oneDay) * oneDay;
                if (!axis.ticks.some(t => t.value === firstDayMidnight)) {
                  axis.ticks.unshift({ value: firstDayMidnight });
                }

                axis.ticks = axis.ticks
                  .map(tick => ({
                    ...tick,
                    value: tick.value + halfDay
                  }))
                  .filter(tick => tick.value <= axis.max);
              }
            },
            y: { beginAtZero: false }
          }
        }
      });
    });
  </script>
{% endblock %}
