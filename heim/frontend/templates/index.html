{% extends "layout.html" %}

{% block body %}
  <nav class="container-fluid">
    <ul>
      <li><strong>Heim</strong></li>
    </ul>
    <ul>
      {% for location in locations %}
        <li>
          <a href="/{{ location.id }}/" {% if location.id == current_location.id %}aria-current="page"{% endif %}>
            {{ location.name }}
          </a>
        </li>
      {% endfor %}
    </ul>
    <ul>
      <li><a href="/settings/">Settings</a></li>
      <li><a href="/logout/">Log out</a></li>
    </ul>
  </nav>

  <main class="container">
    {% if outdoor_hub_data %}
    <article>
      <header>Outdoor</header>
      <canvas id="outdoor-hub-chart"></canvas>
    </article>
    {% elif forecast_data %}
    <article>
      <header>Forecast</header>
      <canvas id="forecast-chart"></canvas>
    </article>
    {% endif %}

    {% if sensor_data %}
    <article>
      <header>Indoor</header>
      <canvas id="indoor-chart"></canvas>
    </article>
    {% endif %}
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
  <script>
    // Crosshair plugin - draws vertical line at mouse position
    const crosshairPlugin = {
      id: 'crosshair',
      afterEvent: (chart, args) => {
        const { event } = args;
        if (event.type === 'mousemove' && event.x >= chart.chartArea.left && event.x <= chart.chartArea.right) {
          chart._crosshairX = event.x;
          chart._crosshairY = event.y;
          // Update our custom tooltip directly
          updateCustomTooltip(chart);
        } else if (event.type === 'mouseout') {
          chart._crosshairX = null;
          chart._crosshairY = null;
          updateCustomTooltip(chart);
        }
      },
      afterDraw: (chart) => {
        if (chart._crosshairX !== null && chart._crosshairX !== undefined) {
          const ctx = chart.ctx;
          const x = chart._crosshairX;
          const topY = chart.scales.y.top;
          const bottomY = chart.scales.y.bottom;

          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x, topY);
          ctx.lineTo(x, bottomY);
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(150, 150, 255, 0.4)';
          ctx.stroke();
          ctx.restore();
        }
      }
    };
    Chart.register(crosshairPlugin);

    // Custom tooltip positioner - follows mouse
    Chart.Tooltip.positioners.followMouse = function(elements, eventPosition) {
      return {
        x: eventPosition.x,
        y: eventPosition.y
      };
    };

    // Common tooltip and interaction config for all charts
    const commonInteraction = {
      intersect: false,
      mode: 'nearest',
      axis: 'x',
    };

    // Find nearest value at x position for a dataset
    function getValueAtPosition(dataset, xPos) {
      const data = dataset.data;
      if (!data || data.length === 0) return null;

      // Get data range
      const firstX = data[0].x instanceof Date ? data[0].x.getTime() : data[0].x;
      const lastX = data[data.length - 1].x instanceof Date ? data[data.length - 1].x.getTime() : data[data.length - 1].x;

      // Don't show values outside the data range
      if (xPos < firstX || xPos > lastX) return null;

      // Find the nearest point to xPos
      let nearest = null;
      let nearestDist = Infinity;
      for (let i = 0; i < data.length; i++) {
        const point = data[i];
        const px = point.x instanceof Date ? point.x.getTime() : point.x;
        const dist = Math.abs(px - xPos);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearest = point.y;
        }
      }

      return nearest;
    }

    // Get or create tooltip element
    function getOrCreateTooltip(chart) {
      let tooltipEl = chart.canvas.parentNode.querySelector('.custom-tooltip');
      if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.className = 'custom-tooltip';
        tooltipEl.style.cssText = `
          background: rgba(0, 0, 0, 0.8);
          border-radius: 4px;
          color: white;
          opacity: 0;
          pointer-events: none;
          position: absolute;
          transition: opacity 0.1s ease;
          padding: 8px 12px;
          font-size: 12px;
          font-family: system-ui, sans-serif;
          white-space: nowrap;
          z-index: 100;
        `;
        chart.canvas.parentNode.style.position = 'relative';
        chart.canvas.parentNode.appendChild(tooltipEl);
      }
      return tooltipEl;
    }

    // Update custom tooltip - called directly from crosshair plugin
    function updateCustomTooltip(chart) {
      const tooltipEl = getOrCreateTooltip(chart);

      // Hide if mouse not in chart area
      if (!chart._crosshairX) {
        tooltipEl.style.opacity = 0;
        return;
      }

      const xPos = chart._crosshairX;
      const xValue = chart.scales.x.getValueForPixel(xPos);
      const date = new Date(xValue);

      // Build tooltip content
      const title = date.toLocaleString('en-GB', {
        weekday: 'short',
        day: 'numeric',
        month: 'short',
        hour: '2-digit',
        minute: '2-digit'
      });

      let innerHtml = `<div style="margin-bottom: 6px; font-weight: 500;">${title}</div>`;

      chart.data.datasets.forEach((dataset) => {
        const value = getValueAtPosition(dataset, xValue);
        if (value !== null && value !== undefined) {
          // Get the color - handle both function and string colors
          let color = dataset.borderColor;
          const opacity = dataset._opacity || 1;
          if (typeof color === 'function') {
            // For gradient/temperature colors, use the value to get the color
            color = getColorForTemp(value, opacity);
          }
          innerHtml += `
            <div style="display: flex; align-items: center; gap: 6px; margin: 2px 0;">
              <span style="display: inline-block; width: 12px; height: 3px; background: ${color};"></span>
              <span>${dataset.label}: ${value.toFixed(1)}°C</span>
            </div>
          `;
        }
      });

      tooltipEl.innerHTML = innerHtml;
      tooltipEl.style.opacity = 1;

      // Position tooltip following mouse with left/right switching
      const { offsetLeft: positionX, offsetTop: positionY } = chart.canvas;
      const chartCenter = (chart.chartArea.left + chart.chartArea.right) / 2;
      const mouseX = chart._crosshairX || 0;
      const mouseY = chart._crosshairY || 0;

      // Switch sides based on mouse position
      if (mouseX > chartCenter) {
        tooltipEl.style.left = positionX + mouseX - tooltipEl.offsetWidth - 10 + 'px';
      } else {
        tooltipEl.style.left = positionX + mouseX + 10 + 'px';
      }
      tooltipEl.style.top = positionY + mouseY - tooltipEl.offsetHeight / 2 + 'px';
    }

    const commonTooltip = {
      enabled: false,
    };

    // Temperature thresholds and colors for gradient
    // Hard stop at zero: blue below, orange-to-red above
    const tempColorStops = [
      { temp: -20, r: 30, g: 80, b: 180 },    // Dark blue
      { temp: -0.01, r: 70, g: 130, b: 220 }, // Blue (just below zero)
      { temp: 0, r: 230, g: 140, b: 50 },     // Orange (at zero)
      { temp: 20, r: 220, g: 60, b: 60 },     // Red
    ];

    // Get interpolated color for a temperature
    function getColorForTemp(temp, opacity = 1) {
      // Clamp to range
      if (temp <= tempColorStops[0].temp) {
        const s = tempColorStops[0];
        return `rgba(${s.r}, ${s.g}, ${s.b}, ${opacity})`;
      }
      if (temp >= tempColorStops[tempColorStops.length - 1].temp) {
        const s = tempColorStops[tempColorStops.length - 1];
        return `rgba(${s.r}, ${s.g}, ${s.b}, ${opacity})`;
      }

      // Find the two stops to interpolate between
      for (let i = 0; i < tempColorStops.length - 1; i++) {
        const low = tempColorStops[i];
        const high = tempColorStops[i + 1];
        if (temp >= low.temp && temp <= high.temp) {
          const t = (temp - low.temp) / (high.temp - low.temp);
          const r = Math.round(low.r + t * (high.r - low.r));
          const g = Math.round(low.g + t * (high.g - low.g));
          const b = Math.round(low.b + t * (high.b - low.b));
          return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }
      }
      return `rgba(100, 100, 100, ${opacity})`;
    }

    // Cache for gradients
    const gradientCache = new Map();

    // Create a vertical gradient based on y-axis temperature values
    function getTemperatureGradient(context, opacity = 1) {
      const chart = context.chart;
      const { ctx, chartArea, scales } = chart;

      if (!chartArea) {
        return null;
      }

      const yScale = scales.y;
      const cacheKey = `${chartArea.bottom}-${chartArea.top}-${yScale.min}-${yScale.max}-${opacity}`;

      if (!gradientCache.has(cacheKey)) {
        // Gradient from bottom (low temp) to top (high temp)
        const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);

        // Add color stops based on temperature positions
        const steps = 10;
        for (let i = 0; i <= steps; i++) {
          const pos = i / steps;
          const temp = yScale.min + pos * (yScale.max - yScale.min);
          gradient.addColorStop(pos, getColorForTemp(temp, opacity));
        }

        gradientCache.set(cacheKey, gradient);
      }

      return gradientCache.get(cacheKey);
    }

    const outdoorHubData = {{ outdoor_hub_data | tojson }};
    if (outdoorHubData) {
      const ctx = document.getElementById('outdoor-hub-chart');
      const nowTime = new Date(outdoorHubData.now);

      // Build datasets
      const datasets = [];

      // Measurement line (solid, temperature-colored)
      if (outdoorHubData.measurements.labels.length > 0) {
        datasets.push({
          label: 'Measured',
          data: outdoorHubData.measurements.labels.map((l, i) => ({
            x: new Date(l),
            y: outdoorHubData.measurements.values[i]
          })),
          borderColor: (context) => getTemperatureGradient(context, 1),
          tension: 0.1,
          fill: false,
          pointRadius: 0,
          borderWidth: 2,
        });
      }

      // Forecast lines (dashed, temperature-colored with decreasing opacity)
      const forecastOpacities = [1.0, 0.6, 0.3];
      outdoorHubData.forecasts.forEach((forecast, index) => {
        const opacity = forecastOpacities[index] || 0.3;
        datasets.push({
          label: `Forecast (${Math.round(forecast.age_hours)}h ago)`,
          data: forecast.labels.map((l, i) => ({
            x: new Date(l),
            y: forecast.values[i]
          })),
          borderColor: (context) => getTemperatureGradient(context, opacity),
          borderDash: [5, 5],
          tension: 0.1,
          fill: false,
          pointRadius: 0,
          borderWidth: 1.5,
          _opacity: opacity,
        });
      });

      new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          interaction: commonInteraction,
          plugins: {
            tooltip: commonTooltip,
            annotation: {
              annotations: {
                nowLine: {
                  type: 'line',
                  xMin: nowTime,
                  xMax: nowTime,
                  borderColor: 'rgba(150, 150, 255, 0.4)',
                  borderWidth: 1,
                  borderDash: [4, 4],
                  drawTime: 'beforeDatasetsDraw',
                },
                zeroLine: {
                  type: 'line',
                  yMin: 0,
                  yMax: 0,
                  borderColor: 'rgba(150, 150, 255, 0.4)',
                  borderWidth: 1,
                  borderDash: [4, 4],
                }
              }
            },
            legend: {
              display: false
            }
          },
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'day',
              },
              ticks: {
                display: false,
              },
            },
            xLabels: {
              type: 'time',
              position: 'bottom',
              time: {
                unit: 'day',
                displayFormats: {
                  day: 'EEE'
                }
              },
              ticks: {
                maxRotation: 0,
              },
              grid: {
                display: false,
              },
              afterDataLimits: function(axis) {
                axis.min = axis.chart.scales.x.min;
                axis.max = axis.chart.scales.x.max;
              },
              afterBuildTicks: function(axis) {
                const halfDay = 12 * 60 * 60 * 1000;
                const oneDay = 24 * 60 * 60 * 1000;

                const firstDayMidnight = Math.floor(axis.min / oneDay) * oneDay;
                if (!axis.ticks.some(t => t.value === firstDayMidnight)) {
                  axis.ticks.unshift({ value: firstDayMidnight });
                }

                axis.ticks = axis.ticks
                  .map(tick => ({
                    ...tick,
                    value: tick.value + halfDay
                  }))
                  .filter(tick => tick.value <= axis.max);
              }
            },
            y: {
              beginAtZero: false,
              title: {
                display: true,
                text: '°C'
              }
            }
          }
        }
      });
    }

    const forecastData = {{ forecast_data | tojson }};
    if (forecastData && !outdoorHubData) {
      const ctx = document.getElementById('forecast-chart');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: forecastData.labels.map(l => new Date(l)),
          datasets: [{
            label: 'Temperature',
            data: forecastData.values,
            borderColor: '#0d6efd',
            tension: 0.1,
            fill: false,
            pointRadius: 0,
          }]
        },
        options: {
          responsive: true,
          interaction: commonInteraction,
          plugins: {
            tooltip: commonTooltip,
          },
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'day',
              },
              ticks: {
                display: false,
              },
            },
            xLabels: {
              type: 'time',
              position: 'bottom',
              time: {
                unit: 'day',
                displayFormats: {
                  day: 'EEE'
                }
              },
              ticks: {
                maxRotation: 0,
              },
              grid: {
                display: false,
              },
              afterDataLimits: function(axis) {
                // Sync with main x-axis
                axis.min = axis.chart.scales.x.min;
                axis.max = axis.chart.scales.x.max;
              },
              afterBuildTicks: function(axis) {
                const halfDay = 12 * 60 * 60 * 1000;
                const oneDay = 24 * 60 * 60 * 1000;

                // Add tick for first day if missing
                const firstDayMidnight = Math.floor(axis.min / oneDay) * oneDay;
                if (!axis.ticks.some(t => t.value === firstDayMidnight)) {
                  axis.ticks.unshift({ value: firstDayMidnight });
                }

                axis.ticks = axis.ticks
                  .map(tick => ({
                    ...tick,
                    value: tick.value + halfDay
                  }))
                  .filter(tick => tick.value <= axis.max);
              }
            },
            y: { beginAtZero: false }
          }
        }
      });
    }

    const sensorData = {{ sensor_data | tojson }};
    const now = new Date();
    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    // Generate a stable color from sensor ID using a simple hash
    function getColorForSensor(sensorId) {
      // Use golden ratio to spread colors evenly
      const hue = (sensorId * 137.508) % 360;
      return `hsl(${hue}, 70%, 50%)`;
    }

    if (sensorData.length > 0) {
      const ctx = document.getElementById('indoor-chart');
      const datasets = sensorData.map(sensor => ({
        label: sensor.name,
        data: sensor.labels.map((l, i) => ({
          x: new Date(l),
          y: sensor.values[i]
        })),
        borderColor: sensor.color || getColorForSensor(sensor.id),
        tension: 0.1,
        fill: false,
        pointRadius: 0,
        borderWidth: 2,
      }));

      new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          interaction: commonInteraction,
          plugins: {
            tooltip: commonTooltip,
            legend: {
              display: true,
              position: 'right',
              labels: {
                usePointStyle: true,
                pointStyle: 'line',
              }
            }
          },
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'day',
              },
              min: oneWeekAgo,
              max: now,
              ticks: {
                display: false,
              },
            },
            xLabels: {
              type: 'time',
              position: 'bottom',
              min: oneWeekAgo,
              max: now,
              time: {
                unit: 'day',
                displayFormats: {
                  day: 'EEE'
                }
              },
              ticks: {
                maxRotation: 0,
              },
              grid: {
                display: false,
              },
              afterBuildTicks: function(axis) {
                const halfDay = 12 * 60 * 60 * 1000;
                const oneDay = 24 * 60 * 60 * 1000;

                // Add tick for first day if missing
                const firstDayMidnight = Math.floor(axis.min / oneDay) * oneDay;
                if (!axis.ticks.some(t => t.value === firstDayMidnight)) {
                  axis.ticks.unshift({ value: firstDayMidnight });
                }

                axis.ticks = axis.ticks
                  .map(tick => ({
                    ...tick,
                    value: tick.value + halfDay
                  }))
                  .filter(tick => tick.value <= axis.max);
              }
            },
            y: {
              beginAtZero: false,
              grace: '5%',
              title: {
                display: true,
                text: '°C'
              }
            }
          }
        }
      });
    }
  </script>
{% endblock %}
