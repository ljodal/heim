{% extends "layout.html" %}

{% block body %}
  <nav class="navbar navbar-expand-lg navbar-dark bg-danger sticky-top">
    <div class="container-fluid">
      <span class="navbar-brand">
        Heim
      </span>

      <div class="justify-content-md-center" id="location-switcher">
        <div class="d-flex">
          <div class="btn-group">
            {% for location in locations %}
              <a class="btn btn-outline-light btn-sm {% if location.id == current_location.id %}active{% endif %}" href="/{{ location.id }}/">
                {{ location.name }}
              </a>
            {% endfor %}
          </div>
        </div>
      </div>

      <ul class="navbar-nav">
        <li class="nav-item">
          <a href="/settings/" class="nav-link">Settings</a>
        </li>
        <li class="nav-item">
          <a href="/logout/" class="nav-link">Log out</a>
        </li>
      </ul>
    </div>
  </nav>

  <main class="container">
    <div class="row">
      {% if outdoor_hub_data %}
      <div class="col-12 mt-4">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">Outdoor</h5>
            <canvas id="outdoor-hub-chart"></canvas>
          </div>
        </div>
      </div>
      {% elif forecast_data %}
      <div class="col-12 mt-4">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">Forecast</h5>
            <canvas id="forecast-chart"></canvas>
          </div>
        </div>
      </div>
      {% endif %}
      {% if sensor_data %}
      <div class="col-12 mt-4">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">Indoor</h5>
            <canvas id="indoor-chart"></canvas>
          </div>
        </div>
      </div>
      {% endif %}
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
  <script>
    // Crosshair plugin - draws vertical line at mouse position
    const crosshairPlugin = {
      id: 'crosshair',
      afterEvent: (chart, args) => {
        const { event } = args;
        if (event.type === 'mousemove' && event.x >= chart.chartArea.left && event.x <= chart.chartArea.right) {
          chart._crosshairX = event.x;
        } else if (event.type === 'mouseout') {
          chart._crosshairX = null;
        }
      },
      afterDraw: (chart) => {
        if (chart._crosshairX !== null && chart._crosshairX !== undefined) {
          const ctx = chart.ctx;
          const x = chart._crosshairX;
          const topY = chart.scales.y.top;
          const bottomY = chart.scales.y.bottom;

          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x, topY);
          ctx.lineTo(x, bottomY);
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(150, 150, 255, 0.4)';
          ctx.stroke();
          ctx.restore();
        }
      }
    };
    Chart.register(crosshairPlugin);

    // Custom tooltip positioner - follows mouse
    Chart.Tooltip.positioners.followMouse = function(elements, eventPosition) {
      return {
        x: eventPosition.x,
        y: eventPosition.y
      };
    };

    // Common tooltip and interaction config for all charts
    const commonInteraction = {
      intersect: false,
      mode: 'nearest',
      axis: 'x',
    };

    // Find value at x position for a dataset (step function - shows previous reading)
    function getValueAtPosition(dataset, xPos) {
      const data = dataset.data;
      if (!data || data.length === 0) return null;

      // Get data range
      const firstX = data[0].x instanceof Date ? data[0].x.getTime() : data[0].x;
      const lastX = data[data.length - 1].x instanceof Date ? data[data.length - 1].x.getTime() : data[data.length - 1].x;

      // Don't show values outside the data range
      if (xPos < firstX || xPos > lastX) return null;

      // Find the last point at or before xPos
      let lastBefore = null;
      for (let i = 0; i < data.length; i++) {
        const point = data[i];
        const px = point.x instanceof Date ? point.x.getTime() : point.x;
        if (px <= xPos) lastBefore = point.y;
      }

      return lastBefore;
    }

    const commonTooltip = {
      position: 'followMouse',
      callbacks: {
        title: (items, data) => {
          if (!items.length) return '';
          const chart = items[0].chart;
          const xPos = chart._crosshairX;
          if (!xPos) return '';
          const xValue = chart.scales.x.getValueForPixel(xPos);
          const date = new Date(xValue);
          return date.toLocaleString('en-GB', {
            weekday: 'short',
            day: 'numeric',
            month: 'short',
            hour: '2-digit',
            minute: '2-digit'
          });
        },
        beforeBody: (items) => {
          if (!items.length) return [];
          const chart = items[0].chart;
          const xPos = chart._crosshairX;
          if (!xPos) return [];

          const xValue = chart.scales.x.getValueForPixel(xPos);
          const lines = [];

          chart.data.datasets.forEach((dataset) => {
            const value = getValueAtPosition(dataset, xValue);
            if (value !== null && value !== undefined) {
              lines.push(`${dataset.label}: ${value.toFixed(1)}°C`);
            }
          });

          return lines;
        },
        label: () => null, // We handle all labels in beforeBody
      },
    };

    // Temperature thresholds and colors for gradient
    // Hard stop at zero: blue below, orange-to-red above
    const tempColorStops = [
      { temp: -20, r: 30, g: 80, b: 180 },    // Dark blue
      { temp: -0.01, r: 70, g: 130, b: 220 }, // Blue (just below zero)
      { temp: 0, r: 230, g: 140, b: 50 },     // Orange (at zero)
      { temp: 20, r: 220, g: 60, b: 60 },     // Red
    ];

    // Get interpolated color for a temperature
    function getColorForTemp(temp, opacity = 1) {
      // Clamp to range
      if (temp <= tempColorStops[0].temp) {
        const s = tempColorStops[0];
        return `rgba(${s.r}, ${s.g}, ${s.b}, ${opacity})`;
      }
      if (temp >= tempColorStops[tempColorStops.length - 1].temp) {
        const s = tempColorStops[tempColorStops.length - 1];
        return `rgba(${s.r}, ${s.g}, ${s.b}, ${opacity})`;
      }

      // Find the two stops to interpolate between
      for (let i = 0; i < tempColorStops.length - 1; i++) {
        const low = tempColorStops[i];
        const high = tempColorStops[i + 1];
        if (temp >= low.temp && temp <= high.temp) {
          const t = (temp - low.temp) / (high.temp - low.temp);
          const r = Math.round(low.r + t * (high.r - low.r));
          const g = Math.round(low.g + t * (high.g - low.g));
          const b = Math.round(low.b + t * (high.b - low.b));
          return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }
      }
      return `rgba(100, 100, 100, ${opacity})`;
    }

    // Cache for gradients
    const gradientCache = new Map();

    // Create a vertical gradient based on y-axis temperature values
    function getTemperatureGradient(context, opacity = 1) {
      const chart = context.chart;
      const { ctx, chartArea, scales } = chart;

      if (!chartArea) {
        return null;
      }

      const yScale = scales.y;
      const cacheKey = `${chartArea.bottom}-${chartArea.top}-${yScale.min}-${yScale.max}-${opacity}`;

      if (!gradientCache.has(cacheKey)) {
        // Gradient from bottom (low temp) to top (high temp)
        const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);

        // Add color stops based on temperature positions
        const steps = 10;
        for (let i = 0; i <= steps; i++) {
          const pos = i / steps;
          const temp = yScale.min + pos * (yScale.max - yScale.min);
          gradient.addColorStop(pos, getColorForTemp(temp, opacity));
        }

        gradientCache.set(cacheKey, gradient);
      }

      return gradientCache.get(cacheKey);
    }

    const outdoorHubData = {{ outdoor_hub_data | tojson }};
    if (outdoorHubData) {
      const ctx = document.getElementById('outdoor-hub-chart');
      const nowTime = new Date(outdoorHubData.now);

      // Build datasets
      const datasets = [];

      // Measurement line (solid, temperature-colored)
      if (outdoorHubData.measurements.labels.length > 0) {
        datasets.push({
          label: 'Measured',
          data: outdoorHubData.measurements.labels.map((l, i) => ({
            x: new Date(l),
            y: outdoorHubData.measurements.values[i]
          })),
          borderColor: (context) => getTemperatureGradient(context, 1),
          tension: 0.1,
          fill: false,
          pointRadius: 0,
          borderWidth: 2,
        });
      }

      // Forecast lines (dashed, temperature-colored with decreasing opacity)
      const forecastOpacities = [1.0, 0.6, 0.3];
      outdoorHubData.forecasts.forEach((forecast, index) => {
        const opacity = forecastOpacities[index] || 0.3;
        datasets.push({
          label: `Forecast (${Math.round(forecast.age_hours)}h ago)`,
          data: forecast.labels.map((l, i) => ({
            x: new Date(l),
            y: forecast.values[i]
          })),
          borderColor: (context) => getTemperatureGradient(context, opacity),
          borderDash: [5, 5],
          tension: 0.1,
          fill: false,
          pointRadius: 0,
          borderWidth: 1.5,
        });
      });

      new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          interaction: commonInteraction,
          plugins: {
            tooltip: commonTooltip,
            annotation: {
              annotations: {
                nowLine: {
                  type: 'line',
                  xMin: nowTime,
                  xMax: nowTime,
                  borderColor: 'rgba(150, 150, 255, 0.4)',
                  borderWidth: 1,
                  borderDash: [4, 4],
                  drawTime: 'beforeDatasetsDraw',
                },
                zeroLine: {
                  type: 'line',
                  yMin: 0,
                  yMax: 0,
                  borderColor: 'rgba(150, 150, 255, 0.4)',
                  borderWidth: 1,
                  borderDash: [4, 4],
                }
              }
            },
            legend: {
              display: false
            }
          },
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'day',
              },
              ticks: {
                display: false,
              },
            },
            xLabels: {
              type: 'time',
              position: 'bottom',
              time: {
                unit: 'day',
                displayFormats: {
                  day: 'EEE'
                }
              },
              ticks: {
                maxRotation: 0,
              },
              grid: {
                display: false,
              },
              afterDataLimits: function(axis) {
                axis.min = axis.chart.scales.x.min;
                axis.max = axis.chart.scales.x.max;
              },
              afterBuildTicks: function(axis) {
                const halfDay = 12 * 60 * 60 * 1000;
                const oneDay = 24 * 60 * 60 * 1000;

                const firstDayMidnight = Math.floor(axis.min / oneDay) * oneDay;
                if (!axis.ticks.some(t => t.value === firstDayMidnight)) {
                  axis.ticks.unshift({ value: firstDayMidnight });
                }

                axis.ticks = axis.ticks
                  .map(tick => ({
                    ...tick,
                    value: tick.value + halfDay
                  }))
                  .filter(tick => tick.value <= axis.max);
              }
            },
            y: {
              beginAtZero: false,
              title: {
                display: true,
                text: '°C'
              }
            }
          }
        }
      });
    }

    const forecastData = {{ forecast_data | tojson }};
    if (forecastData && !outdoorHubData) {
      const ctx = document.getElementById('forecast-chart');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: forecastData.labels.map(l => new Date(l)),
          datasets: [{
            label: 'Temperature',
            data: forecastData.values,
            borderColor: '#0d6efd',
            tension: 0.1,
            fill: false,
            pointRadius: 0,
          }]
        },
        options: {
          responsive: true,
          interaction: commonInteraction,
          plugins: {
            tooltip: commonTooltip,
          },
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'day',
              },
              ticks: {
                display: false,
              },
            },
            xLabels: {
              type: 'time',
              position: 'bottom',
              time: {
                unit: 'day',
                displayFormats: {
                  day: 'EEE'
                }
              },
              ticks: {
                maxRotation: 0,
              },
              grid: {
                display: false,
              },
              afterDataLimits: function(axis) {
                // Sync with main x-axis
                axis.min = axis.chart.scales.x.min;
                axis.max = axis.chart.scales.x.max;
              },
              afterBuildTicks: function(axis) {
                const halfDay = 12 * 60 * 60 * 1000;
                const oneDay = 24 * 60 * 60 * 1000;

                // Add tick for first day if missing
                const firstDayMidnight = Math.floor(axis.min / oneDay) * oneDay;
                if (!axis.ticks.some(t => t.value === firstDayMidnight)) {
                  axis.ticks.unshift({ value: firstDayMidnight });
                }

                axis.ticks = axis.ticks
                  .map(tick => ({
                    ...tick,
                    value: tick.value + halfDay
                  }))
                  .filter(tick => tick.value <= axis.max);
              }
            },
            y: { beginAtZero: false }
          }
        }
      });
    }

    const sensorData = {{ sensor_data | tojson }};
    const now = new Date();
    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    // Generate a stable color from sensor ID using a simple hash
    function getColorForSensor(sensorId) {
      // Use golden ratio to spread colors evenly
      const hue = (sensorId * 137.508) % 360;
      return `hsl(${hue}, 70%, 50%)`;
    }

    if (sensorData.length > 0) {
      const ctx = document.getElementById('indoor-chart');
      const datasets = sensorData.map(sensor => ({
        label: sensor.name,
        data: sensor.labels.map((l, i) => ({
          x: new Date(l),
          y: sensor.values[i]
        })),
        borderColor: sensor.color || getColorForSensor(sensor.id),
        tension: 0.1,
        fill: false,
        pointRadius: 0,
        borderWidth: 2,
      }));

      new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          interaction: commonInteraction,
          plugins: {
            tooltip: commonTooltip,
            legend: {
              display: true,
              position: 'right',
              labels: {
                usePointStyle: true,
                pointStyle: 'line',
              }
            }
          },
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'day',
              },
              min: oneWeekAgo,
              max: now,
              ticks: {
                display: false,
              },
            },
            xLabels: {
              type: 'time',
              position: 'bottom',
              min: oneWeekAgo,
              max: now,
              time: {
                unit: 'day',
                displayFormats: {
                  day: 'EEE'
                }
              },
              ticks: {
                maxRotation: 0,
              },
              grid: {
                display: false,
              },
              afterBuildTicks: function(axis) {
                const halfDay = 12 * 60 * 60 * 1000;
                const oneDay = 24 * 60 * 60 * 1000;

                // Add tick for first day if missing
                const firstDayMidnight = Math.floor(axis.min / oneDay) * oneDay;
                if (!axis.ticks.some(t => t.value === firstDayMidnight)) {
                  axis.ticks.unshift({ value: firstDayMidnight });
                }

                axis.ticks = axis.ticks
                  .map(tick => ({
                    ...tick,
                    value: tick.value + halfDay
                  }))
                  .filter(tick => tick.value <= axis.max);
              }
            },
            y: {
              beginAtZero: false,
              grace: '5%',
              title: {
                display: true,
                text: '°C'
              }
            }
          }
        }
      });
    }
  </script>
{% endblock %}
